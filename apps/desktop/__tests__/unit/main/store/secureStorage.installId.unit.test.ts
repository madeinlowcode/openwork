/**
 * @module __tests__/unit/main/store/secureStorage.installId.unit.test
 * @description Testes unitarios para getInstallationId() e getDerivedKey() do secureStorage.
 * Valida persistencia do ID, formato hex, e estabilidade da chave derivada.
 *
 * AIDEV-NOTE: Testa funcoes internas via efeitos observaveis (encryptValue/decryptValue)
 * pois getInstallationId e getDerivedKey nao sao exportadas.
 * AIDEV-WARNING: Nao resetar mockStoreData entre testes — _derivedKey e cacheado no modulo
 */

import { describe, it, expect, vi } from 'vitest';

// Mock electron
vi.mock('electron', () => ({
  app: {
    isPackaged: false,
    getPath: vi.fn(() => '/mock/userData'),
  },
}));

// In-memory store backing — shared across all tests (module caches _derivedKey)
const mockStoreData: Record<string, unknown> = { values: {} };
vi.mock('electron-store', () => {
  return {
    default: class MockStore {
      get(key: string) {
        return mockStoreData[key];
      }
      set(key: string, value: unknown) {
        mockStoreData[key] = value;
      }
      clear() {
        Object.keys(mockStoreData).forEach((k) => delete mockStoreData[k]);
        mockStoreData.values = {};
      }
    },
  };
});

import { encryptValue, decryptValue } from '@main/store/secureStorage';

describe('secureStorage - installationId and key derivation', () => {
  it('encryptValue/decryptValue round-trip works (proves key derivation succeeds)', () => {
    const original = 'test value';
    const encrypted = encryptValue(original);
    const decrypted = decryptValue(encrypted);
    expect(decrypted).toEqual(original);
  });

  it('getInstallationId persists in store after first encrypt call', () => {
    // The previous test already triggered encryptValue, which calls getInstallationId
    const values = mockStoreData.values as Record<string, string>;
    const installId = values['__install_id__'];
    expect(installId).toBeDefined();
    expect(typeof installId).toBe('string');
    // hex format: 32 chars (16 bytes)
    expect(installId).toMatch(/^[0-9a-f]{32}$/);
  });

  it('installationId remains the same across multiple encrypt calls', () => {
    const id1 = (mockStoreData.values as Record<string, string>)['__install_id__'];
    encryptValue('another call');
    const id2 = (mockStoreData.values as Record<string, string>)['__install_id__'];
    expect(id1).toEqual(id2);
  });

  it('salt is generated and stored on first use', () => {
    // Salt was generated by the first encryptValue call
    expect(mockStoreData.salt).toBeDefined();
    expect(typeof mockStoreData.salt).toBe('string');
  });

  it('derived key produces consistent results (same key for same machine data)', () => {
    const value = 'consistency test';
    const enc1 = encryptValue(value);
    const enc2 = encryptValue(value);
    // Different ciphertexts (random IV) but both decrypt correctly
    expect(decryptValue(enc1)).toEqual(value);
    expect(decryptValue(enc2)).toEqual(value);
  });
});
