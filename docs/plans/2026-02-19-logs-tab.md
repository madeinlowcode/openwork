# Logs Tab Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Adicionar aba "Logs" no SettingsDialog mostrando histórico de uso de API por tarefa (colapsável) com detalhes por step e exportação CSV.

**Architecture:** Query direta na tabela SQLite `token_usage` com join em `tasks` para trazer o prompt. Novo IPC handler `token-usage:get-logs`. Hook `useApiLogs` no renderer. Componente `LogsSettings` com accordion de tarefas + sub-tabela de steps + exportação CSV.

**Tech Stack:** better-sqlite3 (main), React + Tailwind (renderer), IPC contextBridge, react-i18next

---

## Contexto Crítico

### Tabela `token_usage` (SQLite)
Colunas relevantes:
```
id, task_id, session_id, model_id, provider, source, step_number,
input_tokens, output_tokens, reasoning_tokens, cache_read_tokens,
cache_write_tokens, cost_usd, is_estimated, created_at
```

`source` é um dos: `'primary' | 'retry' | 'fallback' | 'continuation' | 'summarization'`

### Tabela `tasks` (SQLite)
Colunas relevantes: `id, prompt, status, created_at`

### IPC já existente em `token-usage-handlers.ts`
- `token-usage:get-by-task` — rows de uma tarefa
- `token-usage:get-summary` — view agregada por tarefa
- `token-usage:get-daily-summary` — agregado por dia

### Preload já expõe `window.jurisiar.tokenUsage`
Arquivo: `apps/desktop/src/preload/index.ts`

### Pattern de nova aba no Settings
Ver `apps/desktop/src/renderer/components/layout/SettingsDialog.tsx` — lista de tabs com ícone SVG e label.

---

## Task 1: IPC Handler `token-usage:get-logs`

**Files:**
- Modify: `apps/desktop/src/main/ipc/token-usage-handlers.ts`
- Modify: `apps/desktop/src/preload/index.ts`
- Modify: `apps/desktop/src/renderer/lib/jurisiar.ts`

**Passo 1: Abrir o arquivo handler e adicionar a nova query**

Arquivo: `apps/desktop/src/main/ipc/token-usage-handlers.ts`

Adicionar ao final do arquivo (antes do `}` que fecha a função `registerTokenUsageHandlers`):

```typescript
  // Handler: get-logs — retorna steps agrupados por tarefa para a aba Logs
  // AIDEV-NOTE: JOIN com tasks para trazer prompt; filtra por provider se fornecido
  ipcMain.handle('token-usage:get-logs', (_event, options?: { limit?: number; provider?: string }) => {
    const db = getDb();
    const limit = options?.limit ?? 200;
    const provider = options?.provider;

    let sql = `
      SELECT
        tu.id,
        tu.task_id,
        tu.session_id,
        tu.model_id,
        tu.provider,
        tu.source,
        tu.step_number,
        tu.input_tokens,
        tu.output_tokens,
        tu.reasoning_tokens,
        tu.cache_read_tokens,
        tu.cache_write_tokens,
        tu.cost_usd,
        tu.is_estimated,
        tu.created_at,
        t.prompt as task_prompt,
        t.status as task_status
      FROM token_usage tu
      LEFT JOIN tasks t ON t.id = tu.task_id
    `;

    const params: unknown[] = [];
    if (provider) {
      sql += ` WHERE tu.provider = ?`;
      params.push(provider);
    }

    sql += ` ORDER BY tu.created_at DESC LIMIT ?`;
    params.push(limit);

    return db.prepare(sql).all(...params);
  });
```

**Passo 2: Adicionar `getLogs` no preload**

Arquivo: `apps/desktop/src/preload/index.ts`

Localizar o bloco `tokenUsage:` e adicionar `getLogs`:

```typescript
tokenUsage: {
  getByTask: (taskId: string) => ipcRenderer.invoke('token-usage:get-by-task', taskId),
  getSummary: (taskId: string) => ipcRenderer.invoke('token-usage:get-summary', taskId),
  getDailySummary: (days?: number) => ipcRenderer.invoke('token-usage:get-daily-summary', days),
  getLogs: (options?: { limit?: number; provider?: string }) =>
    ipcRenderer.invoke('token-usage:get-logs', options),
},
```

**Passo 3: Adicionar tipo em `jurisiar.ts`**

Arquivo: `apps/desktop/src/renderer/lib/jurisiar.ts`

Localizar o campo `tokenUsage?` e adicionar `getLogs`:

```typescript
tokenUsage?: {
  getByTask(taskId: string): Promise<unknown[]>;
  getSummary(taskId: string): Promise<unknown | null>;
  getDailySummary(days?: number): Promise<unknown[]>;
  getLogs(options?: { limit?: number; provider?: string }): Promise<unknown[]>;
};
```

**Passo 4: Verificar typecheck**
```bash
cd C:\Users\Script7\Desktop\openwork && pnpm typecheck
```
Esperado: sem erros.

**Passo 5: Commit**
```bash
git add apps/desktop/src/main/ipc/token-usage-handlers.ts apps/desktop/src/preload/index.ts apps/desktop/src/renderer/lib/jurisiar.ts
git commit -m "feat(logs): add token-usage:get-logs IPC handler with task join"
```

---

## Task 2: Hook `useApiLogs`

**Files:**
- Create: `apps/desktop/src/renderer/hooks/useApiLogs.ts`

**Passo 1: Criar o arquivo**

```typescript
/**
 * @hook useApiLogs
 * @description Busca logs detalhados de uso de API agrupados por tarefa.
 *              Cada entrada contém todos os steps de uma sessão com tokens e custo.
 *
 * @param options.limit - Máximo de steps a retornar (padrão: 200)
 * @param options.provider - Filtrar por provider (undefined = todos)
 * @returns { taskGroups, providers, isLoading, error, refetch }
 *
 * @dependencies
 * - react (useState, useEffect, useCallback)
 *
 * @usedBy
 * - components/settings/LogsSettings.tsx
 *
 * AIDEV-NOTE: Agrupa rows por task_id no cliente para evitar SQL complexo
 * AIDEV-WARNING: window.jurisiar.tokenUsage pode ser undefined fora do Electron
 */
import { useState, useEffect, useCallback } from 'react';

export interface LogStep {
  id: string;
  taskId: string;
  sessionId: string | null;
  modelId: string;
  provider: string;
  source: 'primary' | 'retry' | 'fallback' | 'continuation' | 'summarization';
  stepNumber: number | null;
  inputTokens: number;
  outputTokens: number;
  reasoningTokens: number;
  cacheReadTokens: number;
  cacheWriteTokens: number;
  costUsd: number | null;
  isEstimated: number;
  createdAt: string;
  taskPrompt: string | null;
  taskStatus: string | null;
}

export interface TaskLogGroup {
  taskId: string;
  taskPrompt: string | null;
  taskStatus: string | null;
  createdAt: string;
  steps: LogStep[];
  totalInputTokens: number;
  totalOutputTokens: number;
  totalCostUsd: number;
  providers: string[];
  isEstimated: boolean;
}

function groupByTask(rows: LogStep[]): TaskLogGroup[] {
  const map = new Map<string, TaskLogGroup>();

  for (const row of rows) {
    if (!map.has(row.taskId)) {
      map.set(row.taskId, {
        taskId: row.taskId,
        taskPrompt: row.taskPrompt,
        taskStatus: row.taskStatus,
        createdAt: row.createdAt,
        steps: [],
        totalInputTokens: 0,
        totalOutputTokens: 0,
        totalCostUsd: 0,
        providers: [],
        isEstimated: false,
      });
    }
    const group = map.get(row.taskId)!;
    group.steps.push(row);
    group.totalInputTokens += row.inputTokens;
    group.totalOutputTokens += row.outputTokens;
    group.totalCostUsd += row.costUsd ?? 0;
    if (!group.providers.includes(row.provider)) {
      group.providers.push(row.provider);
    }
    if (row.isEstimated) group.isEstimated = true;
  }

  return Array.from(map.values());
}

export function useApiLogs(options?: { limit?: number; provider?: string }) {
  const [taskGroups, setTaskGroups] = useState<TaskLogGroup[]>([]);
  const [providers, setProviders] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetch = useCallback(async () => {
    const api = (window as any).jurisiar?.tokenUsage;
    if (!api?.getLogs) return;

    setIsLoading(true);
    setError(null);

    try {
      const rows = await api.getLogs(options) as LogStep[];
      const groups = groupByTask(rows);
      setTaskGroups(groups);

      // Extrair lista de providers únicos para o filtro
      const allProviders = [...new Set(rows.map((r) => r.provider))];
      setProviders(allProviders);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load logs');
    } finally {
      setIsLoading(false);
    }
  }, [options?.limit, options?.provider]);

  useEffect(() => { fetch(); }, [fetch]);

  return { taskGroups, providers, isLoading, error, refetch: fetch };
}
```

**Passo 2: Commit**
```bash
git add apps/desktop/src/renderer/hooks/useApiLogs.ts
git commit -m "feat(logs): add useApiLogs hook with task grouping"
```

---

## Task 3: Componente `LogsSettings`

**Files:**
- Create: `apps/desktop/src/renderer/components/settings/LogsSettings.tsx`

**Passo 1: Criar o arquivo completo**

```typescript
/**
 * @component LogsSettings
 * @description Aba admin de Logs — exibe histórico de requisições de API agrupado
 *              por tarefa (colapsável) com detalhes por step e exportação CSV.
 *
 * @context Settings Dialog — aba "Logs" (acesso admin)
 *
 * @dependencies
 * - hooks/useApiLogs.ts (useApiLogs, TaskLogGroup, LogStep)
 * - react (useState)
 *
 * @relatedFiles
 * - components/layout/SettingsDialog.tsx (registro da aba)
 * - main/ipc/token-usage-handlers.ts (IPC token-usage:get-logs)
 *
 * AIDEV-NOTE: Exportação CSV usa Blob + URL.createObjectURL — sem libs externas
 * AIDEV-WARNING: getLogs pode ser undefined se IPC não estiver registrado
 */
import { useState, useMemo } from 'react';
import { useApiLogs, type TaskLogGroup, type LogStep } from '@/hooks/useApiLogs';

// ─── Helpers ─────────────────────────────────────────────────────────────────

function formatTokens(n: number): string {
  if (n >= 1_000_000) return `${(n / 1_000_000).toFixed(1)}M`;
  if (n >= 1_000) return `${(n / 1_000).toFixed(1)}k`;
  return String(n);
}

function formatCost(usd: number, estimated = false): string {
  const prefix = estimated ? '~' : '';
  if (usd < 0.0001) return `${prefix}< $0.0001`;
  return `${prefix}$${usd.toFixed(4)}`;
}

function formatTime(iso: string): string {
  try {
    return new Date(iso).toLocaleString('pt-BR', {
      day: '2-digit', month: '2-digit',
      hour: '2-digit', minute: '2-digit',
    });
  } catch {
    return iso;
  }
}

function truncate(s: string | null, max = 60): string {
  if (!s) return '(sem prompt)';
  return s.length > max ? s.slice(0, max) + '…' : s;
}

// ─── Source Badge ─────────────────────────────────────────────────────────────

const SOURCE_STYLES: Record<string, string> = {
  primary:      'bg-muted/40 text-muted-foreground',
  retry:        'bg-yellow-500/15 text-yellow-600 dark:text-yellow-400',
  fallback:     'bg-orange-500/15 text-orange-600 dark:text-orange-400',
  continuation: 'bg-blue-500/15 text-blue-600 dark:text-blue-400',
  summarization:'bg-purple-500/15 text-purple-600 dark:text-purple-400',
};

function SourceBadge({ source }: { source: LogStep['source'] }) {
  return (
    <span className={`inline-block px-1.5 py-0.5 rounded text-[10px] font-medium ${SOURCE_STYLES[source] ?? 'bg-muted/40 text-muted-foreground'}`}>
      {source}
    </span>
  );
}

// ─── Step Row ─────────────────────────────────────────────────────────────────

function StepRow({ step, index }: { step: LogStep; index: number }) {
  const modelShort = step.modelId.split('/').pop() ?? step.modelId;
  return (
    <div className="grid grid-cols-[32px_80px_140px_60px_60px_60px_80px] gap-1 items-center px-3 py-1.5 text-xs border-b border-border/30 last:border-0 hover:bg-muted/10">
      <span className="text-muted-foreground/50 font-mono tabular-nums text-center">
        {index + 1}
      </span>
      <SourceBadge source={step.source} />
      <span className="font-mono text-[11px] text-muted-foreground truncate" title={step.modelId}>
        {modelShort}
      </span>
      <span className="font-mono tabular-nums text-right text-muted-foreground">
        ↑{formatTokens(step.inputTokens)}
      </span>
      <span className="font-mono tabular-nums text-right text-muted-foreground">
        ↓{formatTokens(step.outputTokens)}
      </span>
      <span className="font-mono tabular-nums text-right text-muted-foreground/50">
        {step.cacheReadTokens > 0 ? `⊙${formatTokens(step.cacheReadTokens)}` : '—'}
      </span>
      <span className={`font-mono tabular-nums text-right font-medium ${step.costUsd ? 'text-foreground' : 'text-muted-foreground/50'}`}>
        {step.costUsd !== null ? formatCost(step.costUsd, Boolean(step.isEstimated)) : '—'}
      </span>
    </div>
  );
}

// ─── Task Row (accordion) ─────────────────────────────────────────────────────

function TaskRow({ group }: { group: TaskLogGroup }) {
  const [open, setOpen] = useState(false);
  const providerLabel = group.providers.join(' + ');

  return (
    <div className="border border-border/60 rounded-lg overflow-hidden">
      {/* Header colapsável */}
      <button
        onClick={() => setOpen(!open)}
        className="w-full flex items-start gap-2 px-3 py-2.5 hover:bg-muted/20 transition-colors text-left"
      >
        <span className="mt-0.5 text-muted-foreground shrink-0">
          {open ? '▼' : '▶'}
        </span>
        <div className="flex-1 min-w-0">
          <p className="text-sm text-foreground truncate">{truncate(group.taskPrompt)}</p>
          <p className="text-xs text-muted-foreground mt-0.5">
            {providerLabel} · {group.steps.length} step{group.steps.length !== 1 ? 's' : ''} · {formatCost(group.totalCostUsd, group.isEstimated)}
          </p>
        </div>
        <span className="text-xs text-muted-foreground/60 shrink-0 ml-2">
          {formatTime(group.createdAt)}
        </span>
      </button>

      {/* Steps expandidos */}
      {open && (
        <div className="border-t border-border/40 bg-muted/5">
          {/* Header da tabela */}
          <div className="grid grid-cols-[32px_80px_140px_60px_60px_60px_80px] gap-1 px-3 py-1 text-[10px] text-muted-foreground/50 font-medium uppercase tracking-wide border-b border-border/30">
            <span className="text-center">#</span>
            <span>Source</span>
            <span>Modelo</span>
            <span className="text-right">Input</span>
            <span className="text-right">Output</span>
            <span className="text-right">Cache</span>
            <span className="text-right">Custo</span>
          </div>
          {group.steps.map((step, i) => (
            <StepRow key={step.id} step={step} index={i} />
          ))}
          {/* Totais */}
          <div className="grid grid-cols-[32px_80px_140px_60px_60px_60px_80px] gap-1 px-3 py-1.5 text-xs border-t border-border/40 bg-muted/20">
            <span />
            <span className="text-muted-foreground/50 col-span-2">Total</span>
            <span className="font-mono tabular-nums text-right font-medium">↑{formatTokens(group.totalInputTokens)}</span>
            <span className="font-mono tabular-nums text-right font-medium">↓{formatTokens(group.totalOutputTokens)}</span>
            <span />
            <span className="font-mono tabular-nums text-right font-semibold text-foreground">
              {formatCost(group.totalCostUsd, group.isEstimated)}
            </span>
          </div>
        </div>
      )}
    </div>
  );
}

// ─── Export CSV ───────────────────────────────────────────────────────────────

function exportCsv(taskGroups: TaskLogGroup[]) {
  const rows: string[] = [
    'task_id,task_prompt,step,source,model,provider,input_tokens,output_tokens,reasoning_tokens,cache_read,cache_write,cost_usd,is_estimated,created_at',
  ];

  for (const group of taskGroups) {
    for (const step of group.steps) {
      const prompt = (step.taskPrompt ?? '').replace(/"/g, '""');
      rows.push([
        step.taskId,
        `"${prompt}"`,
        step.stepNumber ?? '',
        step.source,
        step.modelId,
        step.provider,
        step.inputTokens,
        step.outputTokens,
        step.reasoningTokens,
        step.cacheReadTokens,
        step.cacheWriteTokens,
        step.costUsd ?? '',
        step.isEstimated,
        step.createdAt,
      ].join(','));
    }
  }

  const blob = new Blob([rows.join('\n')], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `openwork-logs-${new Date().toISOString().slice(0, 10)}.csv`;
  a.click();
  URL.revokeObjectURL(url);
}

// ─── Main Component ───────────────────────────────────────────────────────────

export function LogsSettings() {
  const [selectedProvider, setSelectedProvider] = useState<string | undefined>();
  const options = useMemo(
    () => ({ limit: 500, provider: selectedProvider }),
    [selectedProvider]
  );

  const { taskGroups, providers, isLoading, error } = useApiLogs(options);

  const isAvailable = !!(window as any).jurisiar?.tokenUsage?.getLogs;

  if (!isAvailable) {
    return (
      <div className="flex items-center justify-center h-40 text-sm text-muted-foreground">
        Logs não disponíveis nesta versão.
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h3 className="text-lg font-semibold text-foreground">Logs de API</h3>
          <p className="text-sm text-muted-foreground mt-0.5">
            Histórico detalhado de requisições por tarefa
          </p>
        </div>
        <div className="flex items-center gap-2">
          {/* Filtro por provider */}
          {providers.length > 1 && (
            <select
              value={selectedProvider ?? ''}
              onChange={(e) => setSelectedProvider(e.target.value || undefined)}
              className="text-xs border border-border/60 rounded-md px-2 py-1.5 bg-background text-foreground focus:outline-none focus:ring-1 focus:ring-ring"
            >
              <option value="">Todos os providers</option>
              {providers.map((p) => (
                <option key={p} value={p}>{p}</option>
              ))}
            </select>
          )}
          {/* Exportar CSV */}
          {taskGroups.length > 0 && (
            <button
              onClick={() => exportCsv(taskGroups)}
              className="flex items-center gap-1.5 text-xs px-3 py-1.5 rounded-md border border-border/60 hover:bg-muted/30 transition-colors text-muted-foreground hover:text-foreground"
            >
              <svg className="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5}
                  d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
              </svg>
              Exportar CSV
            </button>
          )}
        </div>
      </div>

      {/* States */}
      {isLoading && (
        <div className="flex items-center justify-center h-32 text-sm text-muted-foreground">
          Carregando logs...
        </div>
      )}

      {error && (
        <div className="text-sm text-destructive text-center py-4">{error}</div>
      )}

      {!isLoading && !error && taskGroups.length === 0 && (
        <div className="flex items-center justify-center h-32 text-sm text-muted-foreground border border-dashed border-border/60 rounded-lg">
          Nenhum log ainda. Execute uma tarefa para ver os detalhes aqui.
        </div>
      )}

      {/* Lista de tarefas */}
      {!isLoading && taskGroups.length > 0 && (
        <div className="space-y-2 max-h-[420px] overflow-y-auto pr-0.5">
          {taskGroups.map((group) => (
            <TaskRow key={group.taskId} group={group} />
          ))}
        </div>
      )}
    </div>
  );
}

export default LogsSettings;
```

**Passo 2: Commit**
```bash
git add apps/desktop/src/renderer/components/settings/LogsSettings.tsx
git commit -m "feat(logs): add LogsSettings component with accordion + CSV export"
```

---

## Task 4: Registrar aba "Logs" no SettingsDialog

**Files:**
- Modify: `apps/desktop/src/renderer/components/layout/SettingsDialog.tsx`

**Passo 1: Ler o arquivo para entender a estrutura de tabs**

Ler `apps/desktop/src/renderer/components/layout/SettingsDialog.tsx` e identificar:
1. Onde ficam os imports de componentes de Settings
2. O tipo/array de tabs (procurar por `activeTab`, `tabs`, ou similar)
3. Onde fica o bloco de renderização condicional por aba

**Passo 2: Adicionar import**

```typescript
import { LogsSettings } from '@/components/settings/LogsSettings';
```

**Passo 3: Adicionar tab na lista de tabs**

Localizar o array ou objeto de tabs. Adicionar após a aba "Uso":

```typescript
{
  id: 'logs',
  label: 'Logs',
  icon: (
    <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5}
        d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
    </svg>
  ),
},
```

**Passo 4: Adicionar renderização condicional**

Localizar o bloco `{activeTab === 'usage' && <UsageSettings />}` e adicionar logo abaixo:

```typescript
{activeTab === 'logs' && <LogsSettings />}
```

**Passo 5: Verificar typecheck**
```bash
cd C:\Users\Script7\Desktop\openwork && pnpm typecheck
```
Esperado: sem erros.

**Passo 6: Commit**
```bash
git add apps/desktop/src/renderer/components/layout/SettingsDialog.tsx
git commit -m "feat(logs): register Logs tab in SettingsDialog"
```

---

## Task 5: Verificação Final

**Passo 1: Typecheck completo**
```bash
cd C:\Users\Script7\Desktop\openwork && pnpm typecheck
```
Esperado: `Done` sem erros nos dois workspaces.

**Passo 2: Verificar que o app builda**
```bash
cd C:\Users\Script7\Desktop\openwork && pnpm build:desktop 2>&1 | tail -20
```

**Passo 3: Avisar o usuário**

Após tudo implementado e typechecks passando, enviar mensagem:

> "Implementação da aba Logs concluída. Todos os 4 arquivos foram criados/modificados e o typecheck passou. Pode reiniciar o app com `pnpm dev` e testar: Configurações → aba Logs."
